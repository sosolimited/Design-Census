<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.2/lodash.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.js"></script>
  <script src="https://d3js.org/d3-queue.v3.min.js"></script>
  <style>

    /* General styles */

    html {
      font-size: 62.5%;     /* Brings it to 10px, since default is usually 16px. Means 1.0rem = 10px */
    }

    body {
      font-family: sans-serif;
      font-size: 1rem;
      color: black;
      background-color: white;
    }

    /* Chart styles */

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .axis-label {
      font-size: 0.5rem;
    }

    .axis .tick text {
      font-size: 1rem;
    }

    .dot {
      stroke-width: 0.05rem;
      stroke: #000;
    }

    .dot.hovered {
      stroke-width: 0.2rem;
    }

    /* Legend styles */

    #legend .legend-title {
      font-size: 1.2rem;
      text-transform: uppercase;
    }

    #legend circle {
      fill: none;
      stroke: #000;
    }

    #legend .circle-label {
      font-size: 1rem;
    }

    /* Tooltip div */

    div.tooltip {
      position: absolute;
      text-align: left;
      width: 20rem;
      height: 6rem;
      padding: 1rem;
      font: 1.2rem sans-serif;
      background: lightsteelblue;
      border: 0rem;
      border-radius: 0.8rem;
      pointer-events: none;
    }

  </style>
</head>

<body>

    <h1>Data Tool</h1>

    <select id="data-selection-1">
      <option selected disabled>Select question for X axis</option>
    </select>
    <select id="data-selection-2">
      <option selected disabled>Select question for Y axis</option>
    </select>

    <br/><br/>

    <div id="save-csv"><a download="aiga_data.csv" href="" target="_blank">Save CSV</a></div>

    <div id="graph-area"></div>

  <script>

    var questions = undefined,
        responses = undefined,
        // Margins around graph.
        margin = {top: 50, right: 200, bottom: 300, left: 300},
        // Width & height of graph.
        width = 1080 - margin.left - margin.right,
        height = 960 - margin.top - margin.bottom,
        curQuestion1 = undefined,
        curQuestion2 = undefined,
        curResponseData = undefined;

    // Define the div for the tooltip
    var divTooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

    // Create chart container group within SVG element.
    var svg = d3.select('#graph-area').append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
      .append('g')
        // TIP: svg groups ('g') can only be moved using transform-translate.
        .attr('transform', 'translate('+ margin.left +','+ margin.top +')');

    // Create a legend container group within SVG element also.
    var legendLeftPadding = 80;
    var legend = d3.select("#graph-area svg").append('g')
        .attr('id', 'legend')
        .attr('transform', 'translate(' + (margin.left + width + legendLeftPadding) + ',' + 0 + ')');
    legend.append('text')
        .attr('class', 'legend-title')
        // Move the Legend title.
        .attr('x', 0)
        .attr('y', 50)
        .text('Legend');
    legend = legend.append('g')
        .attr('width', (margin.right - legendLeftPadding))
        // Move the circles in the legend.
        .attr('transform', 'translate(0,' + 100 + ')');

    // Load CSV first to remove empty rows from it, then load JSON.
    d3.xhr('data/wco-responses-13dec2016-2.csv').get(function (err, response) {

      var dirtyCSV = response.responseText;
      var cleanCSV = dirtyCSV.split('\n\r').join('');
      var parsedCSV = d3.csv.parse(cleanCSV);

      d3.json("data/wco-questions-13dec2016.json", function(error, json) {
        parseData(json, parsedCSV);
      });

    });

    function parseData(iQuestions, iResponses) {

      questions = iQuestions;
      responses = iResponses;

      var selectableQuestions = questions.filter(function(d){
        if (d.type === "range") { return true; }
        else if (d.type === "choice" && d.attributes.allow_multiple === false) { return true; }
        else { return false; }
      });

// debugger;
console.log('Raw questions', questions)
console.log('Raw responses', responses)

      // Initially setup HTML elements.
      setupHTML(selectableQuestions);
      // Draws the first graph on page load.
      updateGraph(2, 3);

    }

    function setupHTML(iDropDownItems) {

      iDropDownItems.forEach(function(d, i) {
        $('#data-selection-1').append('<option data-question-id='+ d.question +'>'+ d.attributes.slug +'</option>');
        $('#data-selection-2').append('<option data-question-id='+ d.question +'>'+ d.attributes.slug +'</option>');
      });

      $("select").change(function() {
        var qId1 = $('#data-selection-1 option:selected').data('question-id');
        var qId2 = $('#data-selection-2 option:selected').data('question-id');
        if (qId1 !== undefined && qId2 !== undefined) {
          updateGraph(qId1, qId2);
        }
      });

    }

    // NB: iQuestionNum1 is for X scale, iQuestionNum2 is for Y scale.
    function updateGraph(iQuestionNum1, iQuestionNum2) {

console.log('-updateGraph('+iQuestionNum1+', '+iQuestionNum2+')')

      ////////////////////////////////////////////////////////////
      // Part 1: prepare data
      ////////////////////////////////////////////////////////////

      // Get data for provided questions.
      curQuestion1 = _.find(questions, {'question': iQuestionNum1});
      curQuestion2 = _.find(questions, {'question': iQuestionNum2});
      curResponseData = getResponseDataV2(iQuestionNum1, iQuestionNum2);
      var domainQ1 = getQuestionDomain(iQuestionNum1);
      var domainQ2 = getQuestionDomain(iQuestionNum2);
      var domainRadius = [1, (_.maxBy(curResponseData, 'count').count)];
      var rangeRadius = [1.5, 40.5];    // min & max radius for the circles.

      updateSaveCsvData();

// console.log("domainRadius", domainRadius)
// debugger;
console.log('-updateGraph -curResponseData', curResponseData)

      ////////////////////////////////////////////////////////////
      // Part 2: create chart variables
      ////////////////////////////////////////////////////////////

      var xScale, yScale, radiusScale;
      switch (curQuestion1.type) {
        case 'range':
          xScale = d3.scale.linear().range([0, width]);
          break;
        case 'choice':
          xScale = d3.scale.ordinal().rangeRoundPoints([0, width]);
          break;
        default:
          console.error("Unable to choose proper d3.scale for the Question 1's type.")
      }
      switch (curQuestion2.type) {
        case 'range':
          yScale = d3.scale.linear().range([height, 0]);
          break;
        case 'choice':
          yScale = d3.scale.ordinal().rangeRoundPoints([height, 0]);
          break;
        default:
          console.error("Unable to choose proper d3.scale for the Question 2's type.")
      }
      xScale.domain(domainQ1);
      yScale.domain(domainQ2);
      // Use a square root scale to calculate proper radius for a linear area scale.
      radiusScale = d3.scale.pow().exponent(.5).range(rangeRadius).domain(domainRadius);

      var xAxis = d3.svg.axis().scale(xScale).orient('bottom');
      var yAxis = d3.svg.axis().scale(yScale).orient('left');

      ////////////////////////////////////////////////////////////
      // Part 3: draw chart items
      ////////////////////////////////////////////////////////////

      // Delete previous chart, start from scratch.
      $(svg.node()).empty();

      // Draw circles
      svg.selectAll('.dot')
          .data(curResponseData)
        .enter().append('circle')
          .attr('class', 'dot')       // add any number of CSS classes for styling
          .attr('r', function(d){ return radiusScale(d.count); })   // radius
          .attr('cx', function(d){ return xScale(d.x); })   // center-x position
          .attr('cy', function(d){ return yScale(d.y); })   // center-y position
          .style('fill', 'red')       // inject CSS directly using .style()
          .attr('fill-opacity', 0.2) // this is an attribute, not a CSS property, but it might work in CSS too.
          // Hover action for circles.
          .on("mouseover", function(d) {
            divTooltip.transition()
              .duration(200)
              .style("opacity", .9);
            divTooltip
              .html("x: " + d.x + "<br/>y: " + d.y + "<br/>count: " + d.count)
              .style("left", (d3.event.pageX + 40) + "px")
              .style("top", (d3.event.pageY - 28) + "px");
            $(this)
              .addClass('hovered');
          })
          .on("mouseout", function(d) {
            divTooltip.transition()
              .duration(500)
              .style("opacity", 0);
            $(this)
              .removeClass('hovered')
          });

      // Draw axes after circles, so they are layered above them.
      // Draw X axis
      svg.append('g')
          .attr('class', 'x axis')
          .attr('transform', 'translate(0,'+ height +')')
          .call(xAxis)
          .call(tickModifier)
        .append('text')
          .attr('class', 'axis-label')
          .attr('x', width)
          .attr('y', -6)
          .style('text-anchor', 'end')
          .text(curQuestion1.attributes.slug);

      // Draw Y axis
      svg.append('g')
          .attr('class', 'y axis')
          .call(yAxis)
          .call(tickModifier)
        .append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('y', 6)
          .attr('dy', '.71em')
          .style('text-anchor', 'end')
          .text(curQuestion2.attributes.slug);

      // Modify default appearance of ticks on the axes.
      function tickModifier(iQuestionType) {

        // Move X ticks away from axis, for numbers and sideways text ticks.
        var xTicks = d3.selectAll('.x .tick').select('text');
        xTicks
          .attr('x', '0.5rem')
          .attr('y', '5rem')
          .attr('dy', '0rem')
          .style('text-anchor', 'end');
        if (curQuestion1.type === 'choice') {
          xTicks
            .attr('x', '-5rem')
            .attr('y', '.25rem')
            .attr('transform', 'rotate(-90)');
        }

        // Move Y ticks aways from axis.
        var yTicks = d3.selectAll('.y .tick').select('text');
        yTicks
          .attr('x', '-5rem');

      }

      // Recreate legend (every chart has a different maximum value for the largest circle).
      $(legend.node()).empty();

      var legendCircleScale = radiusScale;
      // Add new value to domain, half of current max value.
      legendCircleScale.domain().splice(1, 0, Math.round(legendCircleScale.domain()[1]/2));
      var legendCircleStrokeWidth = 1;

      var legendCircles = legend.selectAll('circle')
          .data(legendCircleScale.domain())
        .enter();
      // Add circles in the legend
      legendCircles.append('circle')
          .attr('r', function(d){ return legendCircleScale(d); })   // radius
          .attr('cx', legend.attr('width')/2)                       // center-x position
          .attr('cy', function(d,i) {                               // center-y position
            // Draw legend circles inside each other, like russian dolls.
            var alignToBottom = (legendCircleScale.range()[1] * 2) - legendCircleScale(d);
            alignToBottom -= ((legendCircleStrokeWidth+2) * (legendCircleScale.domain().length - i));
            return alignToBottom;
          })
          .style('stroke-width', legendCircleStrokeWidth);
      // Add number above each legend circle.
      legendCircles.append('text')
          .attr('class', 'circle-label')
          .attr('x', legend.attr('width')/2)
          .attr('y', function(d,i) {
            var alignAboveCircle = (legendCircleScale.range()[1] * 2) - legendCircleScale(d);
            alignAboveCircle -= ((legendCircleStrokeWidth+2) * (legendCircleScale.domain().length - i));
            // Move number above each legend circle.
            alignAboveCircle -= (legendCircleScale(d) + 6);
            return alignAboveCircle;
          })
          .style('text-anchor', 'middle')
          .text(function(d,i) { return legendCircleScale.domain()[i]; })

    }

    // Data notes:
    // - question.type = "range"    -->   data is NUMBER
    // - question.type = "choice"   -->   data is STRING
    function getQuestionDomain(iQuestionNum) {

      var result = [];

      var curQuestion = _.find(questions, {'question': iQuestionNum});
      if (curQuestion.type === 'choice') {
        result = _.map(curQuestion.attributes.question_choice_options, 'title');
      } else if (curQuestion.type === 'range') {
        result = [curQuestion.attributes.min, curQuestion.attributes.max];
      }

      return result;

    }

    // This version of the function adds data binning.
    function getResponseDataV2(iQuestionNum1, iQuestionNum2) {

      var result = [];
      var resultP1 = [];
      var q1 = _.find(questions, {'question': iQuestionNum1});
      var q2 = _.find(questions, {'question': iQuestionNum2});
      var q1Type = q1.type;
      var q2Type = q2.type;
      var q1Attr = {
        "enable_plus": q1.attributes.enable_plus || false
      };
      var q2Attr = {
        "enable_plus": q2.attributes.enable_plus || false
      };

      ////////////////////////////////////////////////////////////
      // Part 1: combine questions into x,y pairs.
      ////////////////////////////////////////////////////////////

      _.forEach(responses, function(response) {

// debugger;

        var curResult = {};

        _.forOwn(response, function(responseVal, question) {

          // X
          if (Number(question.split('-')[0]) === Number(iQuestionNum1)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q1Type === 'range') {
                responseVal = formatRangeValue(responseVal, q1Attr);
              } else if (q1Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.x = responseVal;
            }
          }
          // Y
          if (Number(question.split('-')[0]) === Number(iQuestionNum2)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q2Type === 'range') {
                responseVal = formatRangeValue(responseVal, q2Attr);
              } else if (q2Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.y = responseVal;
            }
          }

        });

        // Check if result has X and Y before pushing.
        if (curResult.x !== undefined && curResult.y !== undefined) {
          resultP1.push(curResult);
        }

      });

      ////////////////////////////////////////////////////////////
      // Part 2: data binning: count & combine matching x,y pairs.
      ////////////////////////////////////////////////////////////

      var resultP2 = _.uniqWith(resultP1, _.isEqual);
      _.forEach(resultP2, function(d, i) {
        var numDuplicates = _.filter(resultP1, _.matches(d)).length;
        d.count = numDuplicates;
      });

      result = resultP2;

      return result;

    }

    // For each response, combine answers to Q1 and Q2 into an array of response pairs.
    // Ex: [{response1answer1,response1answer2}, {response2answer1,response2answer2}, ...]
    function getResponseDataV1(iQuestionNum1, iQuestionNum2) {

      var result = [];
      var q1 = _.find(questions, {'question': iQuestionNum1});
      var q2 = _.find(questions, {'question': iQuestionNum2});
      var q1Type = q1.type;
      var q2Type = q2.type;
      var q1Attr = {
        "enable_plus": q1.attributes.enable_plus || false       // 'enable_plus' means the max value in range can have a + (ex: '1000+') which needs to be treated.
      };
      var q2Attr = {
        "enable_plus": q2.attributes.enable_plus || false
      };

      _.forEach(responses, function(response) {

// debugger;

        var curResult = {};

        _.forOwn(response, function(responseVal, question){

          // X
          if (Number(question.split('-')[0]) === Number(iQuestionNum1)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q1Type === 'range') {
                responseVal = formatRangeValue(responseVal, q1Attr);
              } else if (q1Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.x = responseVal;
            }
          }
          // Y
          if (Number(question.split('-')[0]) === Number(iQuestionNum2)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q2Type === 'range') {
                responseVal = formatRangeValue(responseVal, q2Attr);
              } else if (q2Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.y = responseVal;
            }
          }

        });

        // Check if result has X and Y before pushing.
        if (curResult.x !== undefined && curResult.y !== undefined) {
          result.push(curResult);
        }

      });

      return result;

    }

    // Special formatting for values from question of type 'range' (typeof = number).
    function formatRangeValue(iValue, iQuestionAttributes) {

      var result = iValue;

      // Remove '+' symbol from some range values like '120+'
      if (iQuestionAttributes.enable_plus) {
        if (typeof result === 'string') {
          if (result.indexOf('+') > -1) {
            result = result.slice(0, -1);
          }
        }
      }
      result = Number(result);

      return result;

    }

    // Special formatting for values from question of type 'choice' (typeof = string).
    function formatChoiceValue(iValue) {

      var result = iValue;

      if (typeof result === 'string') {
        // For values that have attr ["allow_text": true] (like "Other" of "Prefer to self-describe") we need to remove responder's custom response and group together.
        var customEntryMarkerIdx = result.indexOf(';');
        if (customEntryMarkerIdx > -1) {
          result = result.slice(0, customEntryMarkerIdx);
        }
      } else {
        console.error('formatChoiceValue- iValue is not a string.')
      }

      return result;

    }

    function updateSaveCsvData() {
      $("#save-csv a").attr('href', getCSV());
    }

    function getCSV(){

      if (curQuestion1 != undefined &&
          curQuestion2 != undefined &&
          curResponseData != undefined) {

        var csvQuestions = curQuestion1.attributes.slug + ", " + curQuestion2.attributes.slug + ", count";
        var csvResponseData = curResponseData.map(function(row) {
          return (row.x + ", " + row.y + ", " + row.count);
        });

        var csv = csvQuestions + "\n" + csvResponseData.join("\n");
        var result = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);

        return result;

      } else {
        console.warn("Can't export CSV since data in undefined.")
      }

    }


  </script>
</body>