<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.2/lodash.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.js"></script>
  <script src="https://d3js.org/d3-queue.v3.min.js"></script>
  <style>

    html {
      font-size: 62.5%;     /* Brings it to 10px, since default is usually 16px. */
    }

    body {
      font-family: sans-serif;
      font-size: 1rem;
      color: black;
      background-color: white;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .dot {
      stroke-width: 0.5px;
      stroke: #000;
    }

    .label {
      font-size: 0.5rem;
    }

  </style>
</head>

<body>

    <h1>Data Tool</h1>

    <select id="data-selection-1">
      <option selected disabled>Select question for X axis</option>
    </select>
    <select id="data-selection-2">
      <option selected disabled>Select question for Y axis</option>
    </select>

    <div id="graph-area"></div>

  <script>

    var questions = undefined,
        responses = undefined,
        // Margins around graph.
        margin = {top: 50, right: 50, bottom: 300, left: 300},
        // Width & height of graph.
        width = 960 - margin.left - margin.right,
        height = 960 - margin.top - margin.bottom;

    var svg = d3.select("#graph-area").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append('g')
        .attr('transform', 'translate('+ margin.left +','+ margin.top +')');

    // Load CSV first to remove empty rows from it, then load JSON.
    d3.xhr('data/wco-responses-5dec2016.csv').get(function (err, response) {

      var dirtyCSV = response.responseText;
      var cleanCSV = dirtyCSV.split('\n\r').join('');
      var parsedCSV = d3.csv.parse(cleanCSV);

      d3.json("data/wco-questions-2dec2016.json", function(error, json) {
        parseData(json, parsedCSV);
      });

    });

    function parseData(iQuestions, iResponses) {

      questions = iQuestions;
      responses = iResponses;

      var selectableQuestions = questions.filter(function(d){
        if (d.type === "range") { return true; }
        else if (d.type === "choice" && d.attributes.allow_multiple === false) { return true; }
        else { return false; }
      });

// debugger;
console.log('Raw questions', questions)
console.log('Raw responses', responses)

      // Initially setup HTML elements.
      setupHTML(selectableQuestions);
      // Draws the first graph on page load.
      updateGraph(2, 3);

    }

    function setupHTML(iDropDownItems) {

      iDropDownItems.forEach(function(d, i) {
        $('#data-selection-1').append('<option data-question-id='+ d.question +'>'+ d.attributes.slug +'</option>');
        $('#data-selection-2').append('<option data-question-id='+ d.question +'>'+ d.attributes.slug +'</option>');
      });

      $("select").change(function() {
        var qId1 = $('#data-selection-1 option:selected').data('question-id');
        var qId2 = $('#data-selection-2 option:selected').data('question-id');
        if (qId1 !== undefined && qId2 !== undefined) {
          updateGraph(qId1, qId2);
        }
      });

    }

    // NB: iQuestionNum1 is for X scale, iQuestionNum2 is for Y scale.
    function updateGraph(iQuestionNum1, iQuestionNum2) {

console.log('-updateGraph('+iQuestionNum1+', '+iQuestionNum2+')')

      // Part 1: prepare data

      // Get data for provided questions.
      var curQuestion1 = _.find(questions, {'question': iQuestionNum1});
      var curQuestion2 = _.find(questions, {'question': iQuestionNum2});
      var responseData = getResponseDataV2(iQuestionNum1, iQuestionNum2);
      var domainQ1 = getQuestionDomain(iQuestionNum1);
      var domainQ2 = getQuestionDomain(iQuestionNum2);
      var domainRadius = [0, (_.maxBy(responseData, 'count').count + 0.5)];
      var rangeRadius = [1.5, 40.5];    // min & max radius for the circles.

console.log("domainRadius", domainRadius)

// debugger;
console.log('-updateGraph -responseData', responseData)

      // Part 2: create chart vars

      var xScale, yScale, radiusScale;
      switch (curQuestion1.type) {
        case 'range':
          xScale = d3.scale.linear().range([0, width]);
          break;
        case 'choice':
          xScale = d3.scale.ordinal().rangeRoundPoints([0, width]);
          break;
        default:
          console.error("Unable to choose proper d3.scale for the Question 1's type.")
      }
      switch (curQuestion2.type) {
        case 'range':
          yScale = d3.scale.linear().range([height, 0]);
          break;
        case 'choice':
          yScale = d3.scale.ordinal().rangeRoundPoints([height, 0]);
          break;
        default:
          console.error("Unable to choose proper d3.scale for the Question 2's type.")
      }
      xScale.domain(domainQ1);
      yScale.domain(domainQ2);
      radiusScale = d3.scale.linear().range(rangeRadius).domain(domainRadius);

      var xAxis = d3.svg.axis().scale(xScale).orient('bottom');
      var yAxis = d3.svg.axis().scale(yScale).orient('left');

      // Part 3: draw chart items

      $(svg.node()).empty();

      svg.append('g')
          .attr('class', 'x axis')
          .attr('transform', 'translate(0,'+ height +')')
          .call(xAxis).call(tickRotator)
        .append('text')
          .attr('class', 'label')
          .attr('x', width)
          .attr('y', -6)
          .style('text-anchor', 'end')
          .text(curQuestion1.attributes.slug);
      // Rotate X-axis ticks if ticks are text (and not numbers).
      function tickRotator() {
        if (curQuestion1.type === 'choice') {
          d3.selectAll('.tick').select('text')
            .attr('x', '-1rem')
            .attr('y', '.25rem')
            .attr('dy', '0rem')
            .style('text-anchor', 'end')
            .attr('transform', 'rotate(-90)');
        }
      }

      svg.append('g')
          .attr('class', 'y axis')
          .call(yAxis)
        .append('text')
          .attr('class', 'label')
          .attr('transform', 'rotate(-90)')
          .attr('y', 6)
          .attr('dy', '.71em')
          .style('text-anchor', 'end')
          .text(curQuestion2.attributes.slug);

      // Draw circles
      svg.selectAll('.dot')
          .data(responseData)
        .enter().append('circle')
          .attr('class', 'dot')       // add any number of CSS classes for styling
          .attr('r', function(d){ return radiusScale(d.count); })   // radius
          .attr('cx', function(d){ return xScale(d.x); })   // center-x position
          .attr('cy', function(d){ return yScale(d.y); })   // center-y position
          .style('fill', 'red')       // inject CSS directly using .style()
          .attr('fill-opacity', 0.2); // this is an attribute, not a CSS property, but it might work in CSS too.

    }

    // Data notes:
    // - question.type = "range"    -->   data is NUMBER
    // - question.type = "choice"   -->   data is STRING
    function getQuestionDomain(iQuestionNum) {

      var result = [];

      var curQuestion = _.find(questions, {'question': iQuestionNum});
      if (curQuestion.type === 'choice') {
        result = _.map(curQuestion.attributes.question_choice_options, 'title');
      } else if (curQuestion.type === 'range') {
        result = [curQuestion.attributes.min, curQuestion.attributes.max];
      }

      return result;

    }

    // This version of the function adds data binning.
    function getResponseDataV2(iQuestionNum1, iQuestionNum2) {

      var result = [];
      var resultP1 = [];
      var q1 = _.find(questions, {'question': iQuestionNum1});
      var q2 = _.find(questions, {'question': iQuestionNum2});
      var q1Type = q1.type;
      var q2Type = q2.type;
      var q1Attr = {
        "enable_plus": q1.attributes.enable_plus || false
      };
      var q2Attr = {
        "enable_plus": q2.attributes.enable_plus || false
      };

      _.forEach(responses, function(response) {

// debugger;

        var curResult = {};

        _.forOwn(response, function(responseVal, question) {

          // X
          if (Number(question.split('-')[0]) === Number(iQuestionNum1)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q1Type === 'range') {
                responseVal = formatRangeValue(responseVal, q1Attr);
              } else if (q1Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.x = responseVal;
            }
          }
          // Y
          if (Number(question.split('-')[0]) === Number(iQuestionNum2)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q2Type === 'range') {
                responseVal = formatRangeValue(responseVal, q2Attr);
              } else if (q2Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.y = responseVal;
            }
          }

        });

        // Check if result has X and Y before pushing.
        if (curResult.x !== undefined && curResult.y !== undefined) {
          resultP1.push(curResult);
        }

      });

      ////////////////////////////////////////////////////////////////////////

      var resultP2 = _.uniqWith(resultP1, _.isEqual);
      _.forEach(resultP2, function(d, i) {
        var numDuplicates = _.filter(resultP1, _.matches(d)).length;
        d.count = numDuplicates;
      });

      result = resultP2;

      return result;

    }

    // For each response, combine answers to Q1 and Q2 into an array of response pairs.
    // Ex: [{response1answer1,response1answer2}, {response2answer1,response2answer2}, ...]
    function getResponseDataV1(iQuestionNum1, iQuestionNum2) {

      var result = [];
      var q1 = _.find(questions, {'question': iQuestionNum1});
      var q2 = _.find(questions, {'question': iQuestionNum2});
      var q1Type = q1.type;
      var q2Type = q2.type;
      var q1Attr = {
        "enable_plus": q1.attributes.enable_plus || false       // 'enable_plus' means the max value in range can have a + (ex: '1000+') which needs to be treated.
      };
      var q2Attr = {
        "enable_plus": q2.attributes.enable_plus || false
      };

      _.forEach(responses, function(response) {

// debugger;

        var curResult = {};

        _.forOwn(response, function(responseVal, question){

          // X
          if (Number(question.split('-')[0]) === Number(iQuestionNum1)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q1Type === 'range') {
                responseVal = formatRangeValue(responseVal, q1Attr);
              } else if (q1Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.x = responseVal;
            }
          }
          // Y
          if (Number(question.split('-')[0]) === Number(iQuestionNum2)) {
            if (responseVal !== '' && responseVal !== undefined) {
              if (q2Type === 'range') {
                responseVal = formatRangeValue(responseVal, q2Attr);
              } else if (q2Type === 'choice') {
                responseVal = formatChoiceValue(responseVal);
              }
              curResult.y = responseVal;
            }
          }

        });

        // Check if result has X and Y before pushing.
        if (curResult.x !== undefined && curResult.y !== undefined) {
          result.push(curResult);
        }

      });

      return result;

    }

    // Special formatting for values from question of type 'range' (typeof = number).
    function formatRangeValue(iValue, iQuestionAttributes) {

      var result = iValue;

      // Remove '+' symbol from some range values like '120+'
      if (iQuestionAttributes.enable_plus) {
        if (typeof result === 'string') {
          if (result.indexOf('+') > -1) {
            result = result.slice(0, -1);
          }
        }
      }
      result = Number(result);

      return result;

    }

    // Special formatting for values from question of type 'choice' (typeof = string).
    function formatChoiceValue(iValue) {

      var result = iValue;

      if (typeof result === 'string') {
        // For values that have attr ["allow_text": true] (like "Other" of "Prefer to self-describe") we need to remove responder's custom response and group together.
        var customEntryMarkerIdx = result.indexOf(';');
        if (customEntryMarkerIdx > -1) {
          result = result.slice(0, customEntryMarkerIdx);
        }
      } else {
        console.error('formatChoiceValue- iValue is not a string.')
      }

      return result;

    }

  </script>
</body>